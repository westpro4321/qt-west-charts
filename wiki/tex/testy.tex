\chapter{Testy}
Aby osiągnąć wysokiej jakości kod, należy przeprowadzać jego testy. Jest to szczególnie ważne przy tworzeniu bibliotek, gdyż wszelkie błędy w~nich zawarte wpływają negatywnie na programy klientów.
Biblioteką odpowiedzialną za testy w~Qt jest QtTestLib~\footnote{Testy w Qt \url{http://qt-project.org/doc/qt-5.1/qttestlib/qtest-overview.html}}. Biblioteka ta udostępnia narzędzia umożliwiające tworzenie, m.in. testów jednostkowych, testów sterowanych danymi oraz testów wydajnościowych. Jako, że do testowania mojej biblioteki wykorzystam właśnie tę platformę, poniżej opisuję pokrótce jej możliwości. Następnie opisuję sposób i~przypadki testowe, które zostaną sprawdzone na mojej bibliotece.

\section{QtTestLib}
Stworzenie aplikacji testowej w~QtTestLib składa się z~kilku kroków. Pierwszym z~nich jest stworzenie klasy będącej swego rodzaju zbiorem testów jednostkowych. Następnie trzeba zaimplementować same testy jednostkowe, oraz zasilić je danymi, które umożliwią weryfikację poprawności działania testowanego oprogramowania. Kolejnym, opcjonalnym, krokiem jest napisanie testów wydajnościowych. Ostatnim etapem jest stworzenie funkcji \textit{main()}, zbudowanie oraz uruchomienie testów.

\subsection{Klasa testowa}
Podstawą testów jednostkowych jest klasa, którą należy stworzyć. Musi ona dziedziczyć po QObject, a~wszystkie testy jednostkowe muszą być realizowane w~metodach tej klasy. Z~kolei metody te muszą być jej prywatnymi slotami. Zabieg ten jest konieczny, aby QtTestLib mógł wykryć wszystkie nasze testy jednostkowe.


\subsection{Testy jednostkowe}
Testy jednostkowe są zazwyczaj prostymi kawałkami kodu, w~których sprawdzany jest efekt wywołania metody testowanej klasy. Jeśli jest on zgodny z~oczekiwaniami to test jest zaliczany i~system przechodzi do następnego testu. W~przeciwnym przypadku test jest oblewany, a~informacja o~tym zdarzeniu zostaje zapisana w~logu. W~zależności od ustawień aplikacj testowej, może ona zostać w~tym momencie przerwana, bądź kontynuowana. 
QtTestLib udostępnia swoją funkcjonalność za pomocą zbioru makrodefinicji, np:
\begin{itemize}
\item{QVERIFY(warunek) -- sprawdzenie bool-owskiej wartości. Prawda zalicza test.}
\item{QCOMPARE(faktyczna,~oczekiwana) -- porównanie dwóch wartości. Równość zalicza test.}
\end{itemize}


\subsection{Testy sterowane danymi}
Aby stworzyć test sterowany danymi, należy dodać do klasy testowej dwa sloty:
\begin{lstlisting}
void someTest();
void someTest_data();
\end{lstlisting}
Pierwszy ze slotów odpowiada za test jednostkowy, natomiast drugi za dostarczenie danych do owego testu. Takie odseparowanie logiki od danych ułatwia dodawanie nowych danych, gdyż nie powoduje zmian w~kodzie logiki testu. Technika ta bardziej szczegółowo została omówiona w~artykule~\footnote{Testy sterowane danymi \url{http://qt-project.org/doc/qt-4.8/qtestlib-tutorial2.html}}.

\subsection{Testy wydajnościowe}
Tworzenie testów wydajnościowych, czyli tzw. benchmark-ów, jest możliwe za pomocą makra \textit{QBENCHMARK}. Przykładowy test wydajności:
\begin{lstlisting}[caption=Test wydajności, label=code:test]
void TestFoo::simpleTest()
{
	Foo foo;

	QVERIFY(foo.doSomething());

	QBENCHMARK 
	{
		foo.doSomething();
	}
}
\end{lstlisting}

Jak widać, w~jednym miejscu łączone są tutaj dwa testy metody \newline \textit{Foo::doSomething()}. Pierwszy z~nich to poprostu weryfikacja poprawności jej działania. Drugi test odpowiada za test wydajności tej metody. Za pomocą tej techniki oraz testów sterowanych danymi można stworzyć automatyczne testy porównujące wydajność danego rozwiązania dla różnych zbiorów danych.

\subsection{Funkcja main}
Utworzenie funkcji main naszego testu sprowadza się do wykorzystania makra, które jako argument przyjmuje nazwę naszej klasy testowej, np.
\begin{lstlisting}
	QTEST_MAIN(TestFoo)
\end{lstlisting}
Tak utworzona funkcja main spowoduje uruchomienie każdego testu jednostkowego, dla każdego przygotowanego dlań zbioru danych.

\subsection{Uruchomienie testu}
Aby zbudować naszą testową aplikację należy wpisać w~konsoli następujące komendy:
\begin{lstlisting}
qmake -project "CONFIG += qtestlib"
qmake
make
\end{lstlisting}

Następnie należy uruchomić stworzony plik wykonywalny. Jako rezultat jego działania otrzymamy plik z~logami, które należy przeanalizować.

\section{Przypadki testowe}
Poniżej opisuję przypadki testowe przewidziane dla mojej biblioteki. Każdy z~tych testów powinien być uruchamiany podczas testów regresji~\cite{Sacha}.

\subsection{Operacje na serii danych}
Test będzie polegał na dodawaniu, usuwaniu i~modyfikowaniu danych w~serii. Po każdej operacji zawartość serii będzie porównywana z~oczekiwaną zawartością.

\subsection{Poprawność działania adaptera}
Należy przetestować poprawność działania adaptera pośredniczącego w~komunikacji między wykresem, a modelem. Należy sprawdzić poprawność działanie nastęþujących operacji:
\begin{itemize}
\item{dodawanie danych,}
\item{modyfikacja danych,}
\item{usuwanie danych,}
\item{sortowanie.}
\end{itemize}

\subsection{Dostarczanie zdarzeń}
Planuję przesyłać do wykresu zdarzenia, które powinny powodować zaznaczenie, bądź odznaczenie elementu wykresu. Przesłane w~zdarzeniu współrzędne powinny jednoznacznie wskazać, który z~elementów powinien zostać zaznaczony. Należy przetestować również wysyłanie zdarzeń nie trafiających w~żaden element. 

\subsection{Modyfikacja modelu z poziomu wykresu}
W~tym teście preparowane będą zdarzenia imitujące proces mający na celu zmianę danych zawartych w~modelu poprzez modyfikację elementów wykresu.

\subsection{Mapowanie współrzędnych}
Należy wykonać mapowanie współrzędnych całego wykresu na współrzędne wewnętrznego układu współrzędnych i~odwrotnie.


