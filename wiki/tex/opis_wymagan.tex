\chapter{Opis wymagań}
\section{Wstęp}
Istotą tego rozdziału jest opisanie wszystkich wymagań stawianych tworzonej bibliotece. 
Rozdział ten składa się z~dwóch głównych części: opisu wymagań funkcjonalnych i~opisu wymagań pozafunkcjonalnych.\newline
Opis wymagań funkcjonalnych rozpoczynają wymagania stawiane całej bibliotece oraz wymagania odnoszące się do wszystkich tworzonych za jej pomocą wykresów. Następnie zostały przedstawione specyficzne wymagania dotyczące konkretnych typów wykresów.\newline
Opis wymagań pozafunkcjonalnych został dokonany w~kontekście całej biblioteki, a~w~jego skład wchodzą rozważania na temat takich zagadnień jak skalowalność, wydajność czy niezawodność.

\section{Wspólne wymagania funkcjonalne}
%\subsection{Wspólne}
\subsection{Uniwersalny silnik}
Głównym celem projektowanej biblioteki jest udostępnienie programistom uniwersalnego silnika umożliwiającego tworzenie interaktywnych wykresów. Ma to być rozwiązanie generyczne, działające zarówno dla klasycznego Qt jak i~Qt~Quick~2. Po przeanalizowaniu dostępnych rozwiązań w~rozdziale poświęconym przeglądowi dziedziny, łatwo zauważyć, że twórcy przedstawionych tam bibliotek przyjęli jeden z dwóch modeli:
\begin{itemize}
\item{udostępnienie gotowych widgetów, zawierających wykresy,}
\item{udostępnienie logiki wykresu, gotowej do zaprezentowania na jednym ze~specjalnie przygotowanych widoków.}
\end{itemize}
Pierwsze podejście, oferujące gotowe kontrolki, jest bardzo mało uniwersalne oraz niemal wyklucza wykorzystanie w~Qt~Quick.
Mimo iż w~drugim podejściu odseparowano logikę od widoku, nadal jest to rozwiązanie ograniczone ze względu na niewielką liczbę kompatybilnych widoków.
W~tym momencie pojawia się pomysł na stworzeniu silnika generującego pewne abstrakcje, które mogą zostać wyrenderowane na dowolnej powierzchni, np. na kontrolce, w~dokumencie tekstowym czy w~widoku QML. Wydaje się, że jest to podejście na tyle świeże i~uniwersalne, że może się okazać najlepszym.

\subsection{Przenośność}
Biblioteka musi wpisywać się w~politykę Qt brzmiącą: \textit{pisz raz, kompiluj wielokrotnie}. Musi być przenośna na poziomie kodu źródłowego między najważniejszymi wspieranymi przez Qt platformami.
Minimum to uruchomienie na systemach:
\begin{itemize}
\item{Windows NT,}
\item{Linux (Ubuntu).}
\end{itemize}

%\subsection{API w stylu Qt}


\subsection{Qt~Quick}
Projektując tę bibliotekę muszę wziąć pod uwagę jej późniejsze zastosowanie, którym ma być m.in. tworzenie wykresów w~QML. W~tym momencie trzeba poruszyć kwestie związane z~integracją biblioteki z~Qt~Quick.
\subsubsection{Wyeksponowanie klas C++ w QML}
Już na etapie projektowania należy zadbać, aby tworzone struktury były łatwe do wyeksponowania w~QML. 
Tworzenie interfejsów do QML nie jest celem tego projektu, jednak ich implementacja powinna być możliwie łatwa dla programistów decydujących się na korzystanie z~mojej biblioteki.

\subsubsection{Uwzględnienie dostępnych mechanizmów}
W Qt~Quick prezentacja danych została podzielona na widok, model oraz delegaty. Tworzona biblioteka powinna wpisywać się w ten wzorzec. Cenną własnością będzie możliwość współpracy biblioteki z~już istniejącymi komponentami Qt~Quick, np. poprzez pobieranie danych z~obiektu klasy ListModel~\footnote{ListModel \url{http://qt-project.org/doc/qt-5.1/qtqml/qml-qtquick2-listmodel.html}}. Warto wprowadzić również możliwość zmiany delegata służącego do renderowania danego elementu wykresu.

\subsection{Interaktywność}
Projekt musi zakładać pełną interaktywność tworzonych wykresów. Celem projektu nie jest jednak jej implementacja, a~dostarczenie elementów składowych wykresów, które umożliwią realizację interakcji. Najlepszym rozwiązaniem będzie tutaj wzorowanie się na GraphicsView, gdzie funkcje takie jak \textit{boundingRect()} czy \textit{shape()} ułatwiają wykonywanie pewnych operacji, np. porównanie położenia kursora względem elementów graficznych.


\subsection{Elementy składowe wykresów}
Wszystkie wykresy muszą zawierać następujące elementy:
\begin{itemize}
\item{serie z danymi,}
\item{elementy prezentujące pojedyncze próbki danych (słupek, punkt, wycinek kołowy),}
\item{tytuł wykresu,}
\item{legenda,}
\item{dodatkowe elementy dostarczane przez programistów.}
\end{itemize}

Ponadto wykresy umieszczone w~układzie współrzędnych zawierają:
\begin{itemize}
\item{osie,} % i ich skale,}
\item{siatkę.}
\end{itemize}

Wyświetalnie każdego z~elementów wykresu powinno być sterowane przez programistę. Powinna również istnieć możliwość ustawienia tła wykresu.

\subsubsection{Serie danych}
Biblioteka musi obsługiwać próbki danych, które posiadają następujące parametry:
\begin{itemize}
\item{jedna wartość ze specyficznego dla danego wykresu zbioru wartości, będącego podzbiorem zbioru liczb rzeczywistych,}
\item{co najmniej jedna wartość z~dziedziny liczb rzeczywistych. Bardziej złożone wykresy mogą mieć kilka takich wartości.}
\end{itemize}

Serie danych są kontenerami na próbki. Zakładam, że serie próbek zawierają maksymalnie jedną próbkę dla danego wektora z~dziedziny. Niezbędne są operacje dodawania, modyfikowania i~usuwania danych z~serii.
 
\subsubsection{Elementy prezentujące dane}
Każdy z~wykresów posiada specyficzny dla niego element służący do prezentacji danych z~próbki, którego rozmiar lub położenie w~układzie współrzędnych odzwierciedla wartość próbki. Każdy z~elementów może mieć swój podpis. Powinna istnieć możliwość ustawienia tym elementom dwóch piór i~dwóch pędzli -- dla trybu normalnego i~zaznaczenia. Programista powinien mieć możliwość podmiany, dla danego wykresu, klasy takiego elementu na własną, przy czym odpowiedzialność za poprawne odrysowanie się wykresu spada wtedy na programistę.

\subsubsection{Tytuł wykresu i podpisy elementów}
Dla wszelkich napisów będących składowymi wykresu musi być możliwość ustawienia ich treści, fontu oraz koloru.

\subsubsection{Legenda}
Dla wykresów obsługujących wiele serii danych legenda powinna prezentować kolory oraz tytuły tych serii. Natomiast dla wykresów jednoseryjnych prezentowana powinna być informacja o~kolorze i~tytule każdej z~próbek. Legenda powinna przyjmować jedną z~dwóch orientacji: horyzontalną lub wertykalną. Powinna istnieć możliwość zmiany elementu prezentującego kolor za pomocą mechanizmu delegatów.

\subsubsection{Dodatkowe elementy}
Programiści powinni mieć możliwość tworzenia własnych elementów i~dodawania ich do wykresów już istniejących klas. Aby to osiągnąć powinni jedynie zaimplementować odpowiednie interfejsy.

\subsubsection{Osie}
Powinna być możliwość ustawienia pióra służącego do rysowania osi, jej tytułu, gęstości ticków oraz zakresu wartości. Powinna istnieć możliwość przypisania do osi skali innej niż liniowa.

\subsubsection{Siatka}
Powinna istnieć możliwość określenia grubości i~koloru linii oraz ziarnistości samej siatki.

\subsection{Dostępne operacje na wykresach}
\subsubsection{Skalowanie}
Powinno być możliwe skalowanie wykresu. Wykres powinien dostosowywać swój rozmiar do przekazanego mu obszaru przeznaczonego na jego odrysowanie.

\subsubsection{Zaznaczenie elementów reprezentujących próbki}
Zaznaczenie pojedynczego elementu prezentującego dane powinno polegać na zmianie jego stanu na zaznaczony. W~tym stanie element przy odrysowywaniu powinien korzystać ze~specjalnego pióra i~pędzla.

\subsubsection{Zaznaczenie serii}
Powinna istnieć możliwość zaznaczania wszystkich elementów prezentujących dane z~wybranej serii.

\subsubsection{Wspólny układ współrzędnych}
Powinna istnieć możliwość wyświetlania kilku wykresów, również różnych typów, w~jednym układzie współrzędnych.

\section{Wykres kołowy}
Wykres kołowy służy do prezentacji danych z~jednej serii. Każda z~próbek jest prezentowana za pomocą wycinka kołowego o~kącie środkowym proporcjonalnym do prezentowanej wartości, przez co muszą to być wartości rzeczywiste dodatnie. Wartości wszystkich próbek serii sumują się do stu procent, a~suma kątów wewnętrznych wycinków wynosi 360 stopni. Wszystkie wycinki z~danej serii mają wspólny środek oraz jednakowy promień.

\subsection{Wysuwanie wycinka}
Dowolny z~wycinków powinno się dać wysunąć o~zadany dodatni ułamek jego promienia. Proces ten powinien być możliwy do animacji z~zastosowaniem standardowych rozwiązań Qt~\footnote{Animacje w Qt \url{http://qt-project.org/doc/qt-5.1/qtcore/animation-overview.html}}

\subsection{Obracanie wykresu}
Powinna być możliwość obracania wykresu wokół jego środka. Kąt obrotu powinien być dowolną całkowitą wartością, o~jednostce wynoszącej 1/16-tą stopnia -- jest to standardowa w~Qt jednostka. Proces ten powinien być możliwy do animacji.
 

\section{Wykres słupkowy}
Jest to wykres służący do prezentacji danych z~wielu serii. Elementem odpowiedzialnym za prezentację pojednyczej próbki jest tu słupek. Wszystkie słupki danej serii mają ten sam kolor. W~ogólnym przypadku za pomocą tego wykresu można prezentować wartości z~dziedziny liczb rzeczywistych.

\subsection{Orientacja} 
Wykres ten może przyjmować jedną z~dwóch orientacji: horyzontalną bądź wertykalną. Wertykalny wykres słupkowy jest czasem nazywany wykresem kolumnowym. 

\subsection{Stos}
Wykres słupkowy może zostać przedstawiony w~trybie stosowym. Wtedy dla każdej wartości z~dziedziny tworzony jest jeden słupek o~wysokości proporcjonalnej do sumy wartości próbek ze wszystkich serii wykresu. Z~kolei ten słupek jest podzielony na mniejsze cześci o~długościach i~kolorach odpowiednich próbek.  


\section{Wykres liniowy}
W wykresie liniowym dana próbka jest prezentowana za pomocą pojedynczego punktu. Punkty są prezentowane jako koła o~zadanym promieniu. Wartości próbek należą do zbioru liczb rzeczywistych. Punkty danej serii mogą zostać połączone w~łamaną.

\subsection{Łączenie punktów}
Programista powinien mieć możliwość podjęcia wyboru w~kwestii łączenia punktów w~łamaną. Powinien mieć również możliwość zmiany wszystkich parametrów łamanej, tak jak dla elementów odpowiedzialnych za prezentację próbek.

\section{Dodatki}
Wszystkie opisane tu funkcjonalności są opcjonalne, a~ich realizacja nie jest konieczna do zakończenia prac nad biblioteką.

\subsection{Motywy}
Dodatkiem, który podniósłby atrakcyjność wykresów jest wysokopoziomowy mechanizm motywów, podobny do \textit{QStyle}~\footnote{QStyle \url{http://qt-project.org/doc/qt-5.0/qtwidgets/qstyle.html}}. Mechanizm ten powinien umożliwiać tworzenie wykresów o~spójnej kolorystyce oraz czcionkach. Zmiana motywu dla danego wykresu powinna sprowadzać się do prostej operacji.

\subsection{Budowanie wykresu}
Powinno być możliwe animowanie procesu budowania wykresu. Podczas tego procesu kolejne elementy wykresu będą stawały się widoczne, a~elementy odpowiedzialne za prezentację danych powinny stopniowo przyjmować swoje wartości, począwszy od zera.

\subsection{Generowanie plików graficznych}
Powinno być możliwe generowanie na podstawie istniejących wykresów plików graficznych  w~formatach .PNG i~.SVG.


\section{Wymagania pozafunkcjonalne}
\subsection{Wysokiej jakości API}
API tworzonej przeze mnie bilioteki powinno posiadać jak najwięcej z sześciu cech charakteryzujących dobre interfejsy programistyczne:
\begin{itemize}
\item{minimalne,}
\item{kompletne,}
\item{intuicyjne,} 
\item{łatwe do zapamiętania,}
\item{czysta i~prosta semantyka,}
\item{czytelny kod.}
\end{itemize}

Jednak nie są to wszystkie wymagania stawiane projektowanej bibliotece. Aby tworzony przeze mnie kod był czytelny dla innych programistów Qt, musi on wykorzystywać standardowe mechanizmy tej platformy:
\begin{itemize}
\item{statyczny polimorfizm, polegający na tworzeniu podobnych interfejsów dla podobnych, ale niespokrewnionych klas, np. kontenerów. Zastępuje wprowadzanie sztucznych klas bazowych.}
\item{właściwości jako sposób na parametryzowanie obiektów,}
\item{preferowanie przyjmowania wskaźników zamiast referencji do funkcji modyfikujących argumenty,}
\item{asynchroniczna komunikacja między obiektami rozwiązana za pomocą sygnałów i~slotów,}
\item{nazewnictwo, sposób zwracania wartości z~funkcji i~wiele innych opisanych w~załączonym dokumencie~\cite{APIDesign}.}
\end{itemize}

\subsection{Wymienność biblioteki}
Biblioteka powinna wykorzystywać mechanizmy pozwalające na tworzenie bibliotek dynamicznych wymiennych pomiędzy wersjami. Wprowadzenie nowej wersji biblioteki z~niezmienionym interfejsem nie powinno wymagać przebudowania całej aplikacji z~niej korzystającej.

\subsection{Nowoczesność i~uniwersalność}
Biblioteka powinna wykorzystywać możliwie nowe technologie, np. Qt5. Jednak użycie standardu \textit{C++11} nie jest wskazane ze względu na ograniczenie liczby potencjalnych odbiorców. Komponenty dostarczane do użytku programistom powinny być możliwie wysokopoziomowe i~uniwersalne w~użyciu.

\subsection{Wydajność}
Jako, że okoliczności wykorzystania wykresów biurowych są inne niż wykresów technicznych oraz natura ich danych jest dużo bardziej statyczna, optymalizacja nie jest tu kwestią najważniejszą. 
Z~tego powodu oraz z~chęci uniknięcia antywzorca projektowego przedwczesnej optymalizacji, kwestie wydajności bilioteki jest odsuwana na dalszy plan.

\subsection{Niezawodność}
Jak już zostało wcześniej stwierdzone, natura oraz zastosowania wykresów biurowych różnią się od technicznych, a~co za tym idzie, mają również inne wymagania dotyczące niezawodności. Przewiduje się, że biblioteka będzie przeznaczona do aplikacji finansowych i~biurowych, a nie systemów czasu rzeczywistego. Jednakowoż w~celu minimalizacji liczby błędów w~kodzie, powinny zostać zastosowane testy regresji. Zachowanie biblioteki w warunkach ekstremalnych, np. ograniczonego dostępu do zasobów, nie jest głównym celem projektu.

%\subsubsection{Wiarygodnosć}

\subsection{Skalowalność}
Zarówno dodawanie nowych jak i~usuwanie już istniejących elementów biblioteki powinno być łatwe i~nie powinno mieć wpływu na stabilność pracy biblioteki. Dodawanie nowych elementów powinno być możliwe dzięki uniwersalnym interfejsom. Natomiast usuwanie istniejących elementów powinno sprowadzać się do wyłączenia ich z~procesu budowania biblioteki.


\begin{thebibliography}{}

\bibitem[1]{list-model}

\bibitem[2]{animation}

\bibitem[3]{qstyle}

\bibitem[4]{qt-api}
API w stylu Qt \url{http://qt-project.org/wiki/API-Design-Principles}

\end{thebibliography}
