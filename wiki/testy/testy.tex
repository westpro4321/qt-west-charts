\documentclass[11pt,twoside,a4paper,final]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[MeX]{polski}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\bibliographystyle{splncs}

\begin{document}

\date{28 lipca 2013}
\title{QTestLib \\}

\author{Łukasz Szewczyk}
\maketitle


\section{Wstęp}
W celu osiągnięcia kodu o~wysokiej jakości należy przeprowadzać jego testy. Jest to szczególnie ważne przy tworzeniu bibliotek, gdyż wszelkie błędy w~nich zawarte wpływają negatywnie na programy klientów.
Biblioteką odpowiedzialną za testy w~Qt jest QtTestLib~\cite{qtest}. Biblioteka ta udostępnia narzędznia umożliwiające pisanie testów jednostkowych, testów starowanych danymi oraz testów wydajnościowych. 

\section{Testy jednostkowe}
Poniżej opisuję kolejne kroki prowadzące do stworzenia zbioru testów jednostkowych w~Qt.

\subsection{Podstawa}
Podstawą tworzonych testów jednostkowych jest klasa, którą należy stworzyć. Musi ona dziedziczyć po QObject, a~wszystkie testy jednostkowe muszą być realizowane w~metodach tej klasy, z~kolei metody te muszą być prywatnymi slotami. Zabieg ten jest konieczny, aby QTestLib mógł wykryć wszystkie nasze funkcje testowe.

\subsection{Implementacja funkcji testowych}
Funkcje testowe są zazwyczaj prostymi kawałkami kodu, w~których sprawdzany jest efekt wywołania metody testowanej klasy. Jeśli jest on zgodny z~oczekiwaniami to test jest zaliczany i~system przechodzi do następnego testu. W~przeciwnym przypadku test jest oblewany, a~informacja o~tym zdarzeniu zostaje zapisana w~logu. W~zależności od ustawień aplikacj testowej, może ona zostać w~tym momencie przerwana, bądź kontynuowana do samego końca. 
QTestLib swoje funkcjonalności za pomocą zbioru makrodefinicji, przykłady:
\begin{itemize}
\item{QVERIFY(warunek) -- sprawdzenie bool-owskiej wartości. Prawda zalicza test.}
\item{QCOMPARE(faktyczna,~oczekiwana) -- porównanie dwóch wartości. Równość zalicza test.}
\end{itemize}

\subsection{Utworzenie funkcji main}
Utworzenie funkcji main naszego testu sprowadza się do wykorzystania makra, które jako argument przyjmuje nazwę naszej funkcji testowej, np.\newline 
\textit{QTEST\_MAIN(TestOfSomeClass)}. Tak utworzona funkcja main sprawi, że wszystkie nasze funkcje testowe zostaną uruchomione.

\subsection{Uruchomienie testu}
Aby zbudować naszą testową aplikację należy wpisać w~konsoli następujące komendy:
\begin{lstlisting}
qmake -project "CONFIG += qtestlib"
qmake
make
\end{lstlisting}

\section{Testy sterowane danymi}
Aby odseparować logikę testów od danych, którymi będą zasilane, należy utworzyć dla każdego testu dwa sloty:
\begin{lstlisting}
void someTest();
void someTest_data();
\end{lstlisting}
Pierwszy ze slotów odpowiada za test jednostkowy, natomiast drugi za dostarczenie danych do owego testu. Technika ta bardziej szczegółowo została omówiona w~artykule~\cite{datadriven}.
Zastosowanie w tym przypadku makra \textit{QTEST\_MAIN()} spowoduje uruchomienie każdego testu dla wszystkich przygotowanych dlań zestawów danych.

\section{Testy wydajnościowe}
Tworzenie testów wydajnościowych, czyli tzw. benchmark-ów, jest możliwe za pomocą makra \textit{QBENCHMARK}. Przykładowy test:
\begin{lstlisting}
void TestBenchmark::simpleTest()
{
	Foo foo;

	QVERIFY(foo.doSomething());

	QBENCHMARK 
	{
		foo.doSomething();
	}
}
\end{lstlisting}

Za pomocą tej techniki oraz testów sterowanych danymi można stworzyć automatyczne testy porównujące wydajność danego rozwiązania dla różnych zbiorów danych.

\section{Testy w mojej bibliotece}
Testy jednostkowe
Testy regresji


\begin{thebibliography}{}

\bibitem[1]{qtest}
Testy w Qt \url{http://qt-project.org/doc/qt-5.1/qttestlib/qtest-overview.html}
\bibitem[2]{datadriven}
Testy sterowane danymi \url{http://qt-project.org/doc/qt-4.8/qtestlib-tutorial2.html}


\end{thebibliography}

\end{document}
